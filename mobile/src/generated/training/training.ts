// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: training/training.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "training";

/** Generate plan request */
export interface GeneratePlanRequest {
  userId: string;
  planName?: string | undefined;
  description?: string | undefined;
}

/** Training plan request */
export interface TrainingPlanRequest {
  trainingId: string;
}

/** Training plan response */
export interface TrainingPlanResponse {
  trainingPlan?: TrainingPlan | undefined;
}

/** Workout record request */
export interface WorkoutRecordRequest {
  userId: string;
  trainingId: string;
  dayOfWeek: number;
  exerciseRecords: ExerciseRecord[];
  workoutDate: string;
  notes?: string | undefined;
}

/** Workout record response */
export interface WorkoutRecordResponse {
  recordId: string;
  userId: string;
  trainingId: string;
  workoutDate: string;
  exerciseRecords: ExerciseRecord[];
  notes?: string | undefined;
}

/** Progress request */
export interface ProgressRequest {
  userId: string;
  trainingId?: string | undefined;
  startDate?: string | undefined;
  endDate?: string | undefined;
}

/** Progress response */
export interface ProgressResponse {
  userId: string;
  workouts: WorkoutSummary[];
  exerciseProgress: ExerciseProgress[];
}

/** Training plan */
export interface TrainingPlan {
  id: string;
  userId: string;
  name: string;
  description?: string | undefined;
  createdAt: string;
  updatedAt: string;
  isActive: boolean;
  generatedBy: string;
  exercises: Exercise[];
}

/** Exercise */
export interface Exercise {
  id: string;
  name: string;
  description?: string | undefined;
  sets: number;
  /** Can be a range like "8-12" or specific like "10" */
  reps: string;
  /** Rest time in seconds */
  restTime?: number | undefined;
  notes?:
    | string
    | undefined;
  /** 1-7 representing Monday-Sunday */
  dayOfWeek: number;
  /** Order within the day */
  order: number;
}

/** Exercise record */
export interface ExerciseRecord {
  exerciseId: string;
  exerciseName: string;
  completedSets: number;
  /** Array of reps for each set, e.g. ["10", "8", "6"] */
  completedReps: string[];
  /** Weight used (if applicable) */
  weight?: number | undefined;
  notes?: string | undefined;
}

/** Workout summary */
export interface WorkoutSummary {
  workoutDate: string;
  dayOfWeek: number;
  totalExercises: number;
  totalSets: number;
  notes?: string | undefined;
}

/** Exercise progress */
export interface ExerciseProgress {
  exerciseId: string;
  exerciseName: string;
  progressPoints: ProgressPoint[];
}

/** Progress point */
export interface ProgressPoint {
  date: string;
  weight?: number | undefined;
  totalSets?: number | undefined;
  totalReps?: number | undefined;
}

function createBaseGeneratePlanRequest(): GeneratePlanRequest {
  return { userId: "", planName: undefined, description: undefined };
}

export const GeneratePlanRequest: MessageFns<GeneratePlanRequest> = {
  encode(message: GeneratePlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.planName !== undefined) {
      writer.uint32(18).string(message.planName);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.planName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratePlanRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      planName: isSet(object.planName) ? globalThis.String(object.planName) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: GeneratePlanRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.planName !== undefined) {
      obj.planName = message.planName;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratePlanRequest>, I>>(base?: I): GeneratePlanRequest {
    return GeneratePlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratePlanRequest>, I>>(object: I): GeneratePlanRequest {
    const message = createBaseGeneratePlanRequest();
    message.userId = object.userId ?? "";
    message.planName = object.planName ?? undefined;
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseTrainingPlanRequest(): TrainingPlanRequest {
  return { trainingId: "" };
}

export const TrainingPlanRequest: MessageFns<TrainingPlanRequest> = {
  encode(message: TrainingPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trainingId !== "") {
      writer.uint32(10).string(message.trainingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainingPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingPlanRequest {
    return { trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : "" };
  },

  toJSON(message: TrainingPlanRequest): unknown {
    const obj: any = {};
    if (message.trainingId !== "") {
      obj.trainingId = message.trainingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainingPlanRequest>, I>>(base?: I): TrainingPlanRequest {
    return TrainingPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainingPlanRequest>, I>>(object: I): TrainingPlanRequest {
    const message = createBaseTrainingPlanRequest();
    message.trainingId = object.trainingId ?? "";
    return message;
  },
};

function createBaseTrainingPlanResponse(): TrainingPlanResponse {
  return { trainingPlan: undefined };
}

export const TrainingPlanResponse: MessageFns<TrainingPlanResponse> = {
  encode(message: TrainingPlanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trainingPlan !== undefined) {
      TrainingPlan.encode(message.trainingPlan, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainingPlanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingPlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trainingPlan = TrainingPlan.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingPlanResponse {
    return { trainingPlan: isSet(object.trainingPlan) ? TrainingPlan.fromJSON(object.trainingPlan) : undefined };
  },

  toJSON(message: TrainingPlanResponse): unknown {
    const obj: any = {};
    if (message.trainingPlan !== undefined) {
      obj.trainingPlan = TrainingPlan.toJSON(message.trainingPlan);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainingPlanResponse>, I>>(base?: I): TrainingPlanResponse {
    return TrainingPlanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainingPlanResponse>, I>>(object: I): TrainingPlanResponse {
    const message = createBaseTrainingPlanResponse();
    message.trainingPlan = (object.trainingPlan !== undefined && object.trainingPlan !== null)
      ? TrainingPlan.fromPartial(object.trainingPlan)
      : undefined;
    return message;
  },
};

function createBaseWorkoutRecordRequest(): WorkoutRecordRequest {
  return { userId: "", trainingId: "", dayOfWeek: 0, exerciseRecords: [], workoutDate: "", notes: undefined };
}

export const WorkoutRecordRequest: MessageFns<WorkoutRecordRequest> = {
  encode(message: WorkoutRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.trainingId !== "") {
      writer.uint32(18).string(message.trainingId);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(24).int32(message.dayOfWeek);
    }
    for (const v of message.exerciseRecords) {
      ExerciseRecord.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.workoutDate !== "") {
      writer.uint32(42).string(message.workoutDate);
    }
    if (message.notes !== undefined) {
      writer.uint32(50).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkoutRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkoutRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.exerciseRecords.push(ExerciseRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workoutDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkoutRecordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : "",
      dayOfWeek: isSet(object.dayOfWeek) ? globalThis.Number(object.dayOfWeek) : 0,
      exerciseRecords: globalThis.Array.isArray(object?.exerciseRecords)
        ? object.exerciseRecords.map((e: any) => ExerciseRecord.fromJSON(e))
        : [],
      workoutDate: isSet(object.workoutDate) ? globalThis.String(object.workoutDate) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: WorkoutRecordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== "") {
      obj.trainingId = message.trainingId;
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = Math.round(message.dayOfWeek);
    }
    if (message.exerciseRecords?.length) {
      obj.exerciseRecords = message.exerciseRecords.map((e) => ExerciseRecord.toJSON(e));
    }
    if (message.workoutDate !== "") {
      obj.workoutDate = message.workoutDate;
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkoutRecordRequest>, I>>(base?: I): WorkoutRecordRequest {
    return WorkoutRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkoutRecordRequest>, I>>(object: I): WorkoutRecordRequest {
    const message = createBaseWorkoutRecordRequest();
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? "";
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.exerciseRecords = object.exerciseRecords?.map((e) => ExerciseRecord.fromPartial(e)) || [];
    message.workoutDate = object.workoutDate ?? "";
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseWorkoutRecordResponse(): WorkoutRecordResponse {
  return { recordId: "", userId: "", trainingId: "", workoutDate: "", exerciseRecords: [], notes: undefined };
}

export const WorkoutRecordResponse: MessageFns<WorkoutRecordResponse> = {
  encode(message: WorkoutRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordId !== "") {
      writer.uint32(10).string(message.recordId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.trainingId !== "") {
      writer.uint32(26).string(message.trainingId);
    }
    if (message.workoutDate !== "") {
      writer.uint32(34).string(message.workoutDate);
    }
    for (const v of message.exerciseRecords) {
      ExerciseRecord.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.notes !== undefined) {
      writer.uint32(50).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkoutRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkoutRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workoutDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exerciseRecords.push(ExerciseRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkoutRecordResponse {
    return {
      recordId: isSet(object.recordId) ? globalThis.String(object.recordId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : "",
      workoutDate: isSet(object.workoutDate) ? globalThis.String(object.workoutDate) : "",
      exerciseRecords: globalThis.Array.isArray(object?.exerciseRecords)
        ? object.exerciseRecords.map((e: any) => ExerciseRecord.fromJSON(e))
        : [],
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: WorkoutRecordResponse): unknown {
    const obj: any = {};
    if (message.recordId !== "") {
      obj.recordId = message.recordId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== "") {
      obj.trainingId = message.trainingId;
    }
    if (message.workoutDate !== "") {
      obj.workoutDate = message.workoutDate;
    }
    if (message.exerciseRecords?.length) {
      obj.exerciseRecords = message.exerciseRecords.map((e) => ExerciseRecord.toJSON(e));
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkoutRecordResponse>, I>>(base?: I): WorkoutRecordResponse {
    return WorkoutRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkoutRecordResponse>, I>>(object: I): WorkoutRecordResponse {
    const message = createBaseWorkoutRecordResponse();
    message.recordId = object.recordId ?? "";
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? "";
    message.workoutDate = object.workoutDate ?? "";
    message.exerciseRecords = object.exerciseRecords?.map((e) => ExerciseRecord.fromPartial(e)) || [];
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseProgressRequest(): ProgressRequest {
  return { userId: "", trainingId: undefined, startDate: undefined, endDate: undefined };
}

export const ProgressRequest: MessageFns<ProgressRequest> = {
  encode(message: ProgressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.trainingId !== undefined) {
      writer.uint32(18).string(message.trainingId);
    }
    if (message.startDate !== undefined) {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(34).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : undefined,
    };
  },

  toJSON(message: ProgressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== undefined) {
      obj.trainingId = message.trainingId;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressRequest>, I>>(base?: I): ProgressRequest {
    return ProgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressRequest>, I>>(object: I): ProgressRequest {
    const message = createBaseProgressRequest();
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    return message;
  },
};

function createBaseProgressResponse(): ProgressResponse {
  return { userId: "", workouts: [], exerciseProgress: [] };
}

export const ProgressResponse: MessageFns<ProgressResponse> = {
  encode(message: ProgressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.workouts) {
      WorkoutSummary.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.exerciseProgress) {
      ExerciseProgress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workouts.push(WorkoutSummary.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exerciseProgress.push(ExerciseProgress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      workouts: globalThis.Array.isArray(object?.workouts)
        ? object.workouts.map((e: any) => WorkoutSummary.fromJSON(e))
        : [],
      exerciseProgress: globalThis.Array.isArray(object?.exerciseProgress)
        ? object.exerciseProgress.map((e: any) => ExerciseProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProgressResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.workouts?.length) {
      obj.workouts = message.workouts.map((e) => WorkoutSummary.toJSON(e));
    }
    if (message.exerciseProgress?.length) {
      obj.exerciseProgress = message.exerciseProgress.map((e) => ExerciseProgress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressResponse>, I>>(base?: I): ProgressResponse {
    return ProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressResponse>, I>>(object: I): ProgressResponse {
    const message = createBaseProgressResponse();
    message.userId = object.userId ?? "";
    message.workouts = object.workouts?.map((e) => WorkoutSummary.fromPartial(e)) || [];
    message.exerciseProgress = object.exerciseProgress?.map((e) => ExerciseProgress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrainingPlan(): TrainingPlan {
  return {
    id: "",
    userId: "",
    name: "",
    description: undefined,
    createdAt: "",
    updatedAt: "",
    isActive: false,
    generatedBy: "",
    exercises: [],
  };
}

export const TrainingPlan: MessageFns<TrainingPlan> = {
  encode(message: TrainingPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.generatedBy !== "") {
      writer.uint32(66).string(message.generatedBy);
    }
    for (const v of message.exercises) {
      Exercise.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainingPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.generatedBy = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.exercises.push(Exercise.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingPlan {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      generatedBy: isSet(object.generatedBy) ? globalThis.String(object.generatedBy) : "",
      exercises: globalThis.Array.isArray(object?.exercises)
        ? object.exercises.map((e: any) => Exercise.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrainingPlan): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.generatedBy !== "") {
      obj.generatedBy = message.generatedBy;
    }
    if (message.exercises?.length) {
      obj.exercises = message.exercises.map((e) => Exercise.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainingPlan>, I>>(base?: I): TrainingPlan {
    return TrainingPlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainingPlan>, I>>(object: I): TrainingPlan {
    const message = createBaseTrainingPlan();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.isActive = object.isActive ?? false;
    message.generatedBy = object.generatedBy ?? "";
    message.exercises = object.exercises?.map((e) => Exercise.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExercise(): Exercise {
  return {
    id: "",
    name: "",
    description: undefined,
    sets: 0,
    reps: "",
    restTime: undefined,
    notes: undefined,
    dayOfWeek: 0,
    order: 0,
  };
}

export const Exercise: MessageFns<Exercise> = {
  encode(message: Exercise, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.sets !== 0) {
      writer.uint32(32).int32(message.sets);
    }
    if (message.reps !== "") {
      writer.uint32(42).string(message.reps);
    }
    if (message.restTime !== undefined) {
      writer.uint32(48).int32(message.restTime);
    }
    if (message.notes !== undefined) {
      writer.uint32(58).string(message.notes);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(64).int32(message.dayOfWeek);
    }
    if (message.order !== 0) {
      writer.uint32(72).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exercise {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExercise();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sets = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reps = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.restTime = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exercise {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      sets: isSet(object.sets) ? globalThis.Number(object.sets) : 0,
      reps: isSet(object.reps) ? globalThis.String(object.reps) : "",
      restTime: isSet(object.restTime) ? globalThis.Number(object.restTime) : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      dayOfWeek: isSet(object.dayOfWeek) ? globalThis.Number(object.dayOfWeek) : 0,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: Exercise): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.sets !== 0) {
      obj.sets = Math.round(message.sets);
    }
    if (message.reps !== "") {
      obj.reps = message.reps;
    }
    if (message.restTime !== undefined) {
      obj.restTime = Math.round(message.restTime);
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = Math.round(message.dayOfWeek);
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exercise>, I>>(base?: I): Exercise {
    return Exercise.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exercise>, I>>(object: I): Exercise {
    const message = createBaseExercise();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.sets = object.sets ?? 0;
    message.reps = object.reps ?? "";
    message.restTime = object.restTime ?? undefined;
    message.notes = object.notes ?? undefined;
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseExerciseRecord(): ExerciseRecord {
  return { exerciseId: "", exerciseName: "", completedSets: 0, completedReps: [], weight: undefined, notes: undefined };
}

export const ExerciseRecord: MessageFns<ExerciseRecord> = {
  encode(message: ExerciseRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exerciseId !== "") {
      writer.uint32(10).string(message.exerciseId);
    }
    if (message.exerciseName !== "") {
      writer.uint32(18).string(message.exerciseName);
    }
    if (message.completedSets !== 0) {
      writer.uint32(24).int32(message.completedSets);
    }
    for (const v of message.completedReps) {
      writer.uint32(34).string(v!);
    }
    if (message.weight !== undefined) {
      writer.uint32(45).float(message.weight);
    }
    if (message.notes !== undefined) {
      writer.uint32(50).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExerciseRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exerciseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exerciseName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.completedSets = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completedReps.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseRecord {
    return {
      exerciseId: isSet(object.exerciseId) ? globalThis.String(object.exerciseId) : "",
      exerciseName: isSet(object.exerciseName) ? globalThis.String(object.exerciseName) : "",
      completedSets: isSet(object.completedSets) ? globalThis.Number(object.completedSets) : 0,
      completedReps: globalThis.Array.isArray(object?.completedReps)
        ? object.completedReps.map((e: any) => globalThis.String(e))
        : [],
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: ExerciseRecord): unknown {
    const obj: any = {};
    if (message.exerciseId !== "") {
      obj.exerciseId = message.exerciseId;
    }
    if (message.exerciseName !== "") {
      obj.exerciseName = message.exerciseName;
    }
    if (message.completedSets !== 0) {
      obj.completedSets = Math.round(message.completedSets);
    }
    if (message.completedReps?.length) {
      obj.completedReps = message.completedReps;
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseRecord>, I>>(base?: I): ExerciseRecord {
    return ExerciseRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseRecord>, I>>(object: I): ExerciseRecord {
    const message = createBaseExerciseRecord();
    message.exerciseId = object.exerciseId ?? "";
    message.exerciseName = object.exerciseName ?? "";
    message.completedSets = object.completedSets ?? 0;
    message.completedReps = object.completedReps?.map((e) => e) || [];
    message.weight = object.weight ?? undefined;
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseWorkoutSummary(): WorkoutSummary {
  return { workoutDate: "", dayOfWeek: 0, totalExercises: 0, totalSets: 0, notes: undefined };
}

export const WorkoutSummary: MessageFns<WorkoutSummary> = {
  encode(message: WorkoutSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workoutDate !== "") {
      writer.uint32(10).string(message.workoutDate);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(16).int32(message.dayOfWeek);
    }
    if (message.totalExercises !== 0) {
      writer.uint32(24).int32(message.totalExercises);
    }
    if (message.totalSets !== 0) {
      writer.uint32(32).int32(message.totalSets);
    }
    if (message.notes !== undefined) {
      writer.uint32(42).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkoutSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkoutSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workoutDate = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalExercises = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalSets = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkoutSummary {
    return {
      workoutDate: isSet(object.workoutDate) ? globalThis.String(object.workoutDate) : "",
      dayOfWeek: isSet(object.dayOfWeek) ? globalThis.Number(object.dayOfWeek) : 0,
      totalExercises: isSet(object.totalExercises) ? globalThis.Number(object.totalExercises) : 0,
      totalSets: isSet(object.totalSets) ? globalThis.Number(object.totalSets) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: WorkoutSummary): unknown {
    const obj: any = {};
    if (message.workoutDate !== "") {
      obj.workoutDate = message.workoutDate;
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = Math.round(message.dayOfWeek);
    }
    if (message.totalExercises !== 0) {
      obj.totalExercises = Math.round(message.totalExercises);
    }
    if (message.totalSets !== 0) {
      obj.totalSets = Math.round(message.totalSets);
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkoutSummary>, I>>(base?: I): WorkoutSummary {
    return WorkoutSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkoutSummary>, I>>(object: I): WorkoutSummary {
    const message = createBaseWorkoutSummary();
    message.workoutDate = object.workoutDate ?? "";
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.totalExercises = object.totalExercises ?? 0;
    message.totalSets = object.totalSets ?? 0;
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseExerciseProgress(): ExerciseProgress {
  return { exerciseId: "", exerciseName: "", progressPoints: [] };
}

export const ExerciseProgress: MessageFns<ExerciseProgress> = {
  encode(message: ExerciseProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exerciseId !== "") {
      writer.uint32(10).string(message.exerciseId);
    }
    if (message.exerciseName !== "") {
      writer.uint32(18).string(message.exerciseName);
    }
    for (const v of message.progressPoints) {
      ProgressPoint.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExerciseProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exerciseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exerciseName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.progressPoints.push(ProgressPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseProgress {
    return {
      exerciseId: isSet(object.exerciseId) ? globalThis.String(object.exerciseId) : "",
      exerciseName: isSet(object.exerciseName) ? globalThis.String(object.exerciseName) : "",
      progressPoints: globalThis.Array.isArray(object?.progressPoints)
        ? object.progressPoints.map((e: any) => ProgressPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExerciseProgress): unknown {
    const obj: any = {};
    if (message.exerciseId !== "") {
      obj.exerciseId = message.exerciseId;
    }
    if (message.exerciseName !== "") {
      obj.exerciseName = message.exerciseName;
    }
    if (message.progressPoints?.length) {
      obj.progressPoints = message.progressPoints.map((e) => ProgressPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseProgress>, I>>(base?: I): ExerciseProgress {
    return ExerciseProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseProgress>, I>>(object: I): ExerciseProgress {
    const message = createBaseExerciseProgress();
    message.exerciseId = object.exerciseId ?? "";
    message.exerciseName = object.exerciseName ?? "";
    message.progressPoints = object.progressPoints?.map((e) => ProgressPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgressPoint(): ProgressPoint {
  return { date: "", weight: undefined, totalSets: undefined, totalReps: undefined };
}

export const ProgressPoint: MessageFns<ProgressPoint> = {
  encode(message: ProgressPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.weight !== undefined) {
      writer.uint32(21).float(message.weight);
    }
    if (message.totalSets !== undefined) {
      writer.uint32(24).int32(message.totalSets);
    }
    if (message.totalReps !== undefined) {
      writer.uint32(32).int32(message.totalReps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgressPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalSets = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalReps = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressPoint {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
      totalSets: isSet(object.totalSets) ? globalThis.Number(object.totalSets) : undefined,
      totalReps: isSet(object.totalReps) ? globalThis.Number(object.totalReps) : undefined,
    };
  },

  toJSON(message: ProgressPoint): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    if (message.totalSets !== undefined) {
      obj.totalSets = Math.round(message.totalSets);
    }
    if (message.totalReps !== undefined) {
      obj.totalReps = Math.round(message.totalReps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressPoint>, I>>(base?: I): ProgressPoint {
    return ProgressPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressPoint>, I>>(object: I): ProgressPoint {
    const message = createBaseProgressPoint();
    message.date = object.date ?? "";
    message.weight = object.weight ?? undefined;
    message.totalSets = object.totalSets ?? undefined;
    message.totalReps = object.totalReps ?? undefined;
    return message;
  },
};

export interface TrainingService {
  /** Generate a training plan */
  GenerateTrainingPlan(request: GeneratePlanRequest): Promise<TrainingPlanResponse>;
  /** Get training plan details */
  GetTrainingPlan(request: TrainingPlanRequest): Promise<TrainingPlanResponse>;
  /** Record workout performance */
  RecordWorkout(request: WorkoutRecordRequest): Promise<WorkoutRecordResponse>;
  /** Get user progress */
  GetUserProgress(request: ProgressRequest): Promise<ProgressResponse>;
}

export const TrainingServiceServiceName = "training.TrainingService";
export class TrainingServiceClientImpl implements TrainingService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TrainingServiceServiceName;
    this.rpc = rpc;
    this.GenerateTrainingPlan = this.GenerateTrainingPlan.bind(this);
    this.GetTrainingPlan = this.GetTrainingPlan.bind(this);
    this.RecordWorkout = this.RecordWorkout.bind(this);
    this.GetUserProgress = this.GetUserProgress.bind(this);
  }
  GenerateTrainingPlan(request: GeneratePlanRequest): Promise<TrainingPlanResponse> {
    const data = GeneratePlanRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateTrainingPlan", data);
    return promise.then((data) => TrainingPlanResponse.decode(new BinaryReader(data)));
  }

  GetTrainingPlan(request: TrainingPlanRequest): Promise<TrainingPlanResponse> {
    const data = TrainingPlanRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTrainingPlan", data);
    return promise.then((data) => TrainingPlanResponse.decode(new BinaryReader(data)));
  }

  RecordWorkout(request: WorkoutRecordRequest): Promise<WorkoutRecordResponse> {
    const data = WorkoutRecordRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RecordWorkout", data);
    return promise.then((data) => WorkoutRecordResponse.decode(new BinaryReader(data)));
  }

  GetUserProgress(request: ProgressRequest): Promise<ProgressResponse> {
    const data = ProgressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserProgress", data);
    return promise.then((data) => ProgressResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
