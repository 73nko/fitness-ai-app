// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: ai/ai.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "ai";

/** User profile for AI training plan generation */
export interface UserProfile {
  userId: string;
  age: number;
  height: number;
  weight: number;
  /** beginner, intermediate, advanced */
  fitnessLevel: string;
  /** ["lose_weight", "build_muscle", etc.] */
  fitnessGoals: string[];
  medicalIssues: string[];
  availableEquipment: string[];
  /** JSON string for additional preferences */
  trainingPreferences: string;
  /** Number of days per week the user can train */
  daysPerWeek: number;
  /** Specific body areas to focus on */
  focusAreas?: string | undefined;
}

/** Training plan generated by AI */
export interface TrainingPlan {
  id: string;
  userId: string;
  name: string;
  objective: string;
  description: string;
  daysPerWeek: number;
  sessions: TrainingSession[];
  generatedAt: string;
  modelUsed: string;
}

/** Training session for specific day */
export interface TrainingSession {
  /** 1-7 representing Monday-Sunday */
  dayOfWeek: number;
  /** e.g., "Upper Body", "Lower Body", "Full Body", etc. */
  focus: string;
  exercises: ExercisePlan[];
  /** In minutes */
  estimatedDuration: number;
  notes?: string | undefined;
}

/** Exercise plan */
export interface ExercisePlan {
  name: string;
  description: string;
  sets: number;
  /** Can be a range like "8-12" or specific like "10" */
  reps: string;
  restSeconds: number;
  notes?:
    | string
    | undefined;
  /** Order within the session */
  order: number;
}

/** Feedback request */
export interface FeedbackRequest {
  userId: string;
  trainingId?: string | undefined;
  startDate?: string | undefined;
  endDate?: string | undefined;
}

/** Feedback response */
export interface FeedbackResponse {
  userId: string;
  feedback: string;
  exerciseFeedback: ExerciseFeedback[];
  generatedAt: string;
  modelUsed: string;
}

/** Exercise feedback */
export interface ExerciseFeedback {
  exerciseId: string;
  exerciseName: string;
  feedback: string;
  suggestion?: string | undefined;
}

/** Recommendation request */
export interface RecommendationRequest {
  userId: string;
  trainingId?: string | undefined;
  focusArea?: string | undefined;
}

/** Recommendation response */
export interface RecommendationResponse {
  userId: string;
  recommendations: ExerciseRecommendation[];
  generatedAt: string;
  modelUsed: string;
}

/** Exercise recommendation */
export interface ExerciseRecommendation {
  exerciseName: string;
  description: string;
  benefit: string;
  videoUrl?: string | undefined;
  imageUrl?: string | undefined;
  recommendedSets: number;
  recommendedReps: string;
  recommendedRest: number;
}

/** Progress analysis request */
export interface ProgressAnalysisRequest {
  userId: string;
  trainingId?: string | undefined;
  startDate?: string | undefined;
  endDate?: string | undefined;
}

/** Progress analysis response */
export interface ProgressAnalysisResponse {
  userId: string;
  overallAnalysis: string;
  strengthAreas: StrengthAreaAnalysis[];
  weaknessAreas: WeaknessAreaAnalysis[];
  actionItems: ActionItem[];
  generatedAt: string;
  modelUsed: string;
}

/** Strength area analysis */
export interface StrengthAreaAnalysis {
  area: string;
  description: string;
  improvementPercentage: number;
}

/** Weakness area analysis */
export interface WeaknessAreaAnalysis {
  area: string;
  description: string;
  suggestion?: string | undefined;
}

/** Action item */
export interface ActionItem {
  description: string;
  reason: string;
  /** 1-5 scale, 5 being highest priority */
  priority: number;
}

function createBaseUserProfile(): UserProfile {
  return {
    userId: "",
    age: 0,
    height: 0,
    weight: 0,
    fitnessLevel: "",
    fitnessGoals: [],
    medicalIssues: [],
    availableEquipment: [],
    trainingPreferences: "",
    daysPerWeek: 0,
    focusAreas: undefined,
  };
}

export const UserProfile = {
  encode(message: UserProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.age !== 0) {
      writer.uint32(16).int32(message.age);
    }
    if (message.height !== 0) {
      writer.uint32(29).float(message.height);
    }
    if (message.weight !== 0) {
      writer.uint32(37).float(message.weight);
    }
    if (message.fitnessLevel !== "") {
      writer.uint32(42).string(message.fitnessLevel);
    }
    for (const v of message.fitnessGoals) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.medicalIssues) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.availableEquipment) {
      writer.uint32(66).string(v!);
    }
    if (message.trainingPreferences !== "") {
      writer.uint32(74).string(message.trainingPreferences);
    }
    if (message.daysPerWeek !== 0) {
      writer.uint32(80).int32(message.daysPerWeek);
    }
    if (message.focusAreas !== undefined) {
      writer.uint32(90).string(message.focusAreas);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.age = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.weight = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fitnessLevel = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fitnessGoals.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.medicalIssues.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.availableEquipment.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.trainingPreferences = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.daysPerWeek = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.focusAreas = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      fitnessLevel: isSet(object.fitnessLevel) ? globalThis.String(object.fitnessLevel) : "",
      fitnessGoals: globalThis.Array.isArray(object?.fitnessGoals)
        ? object.fitnessGoals.map((e: any) => globalThis.String(e))
        : [],
      medicalIssues: globalThis.Array.isArray(object?.medicalIssues)
        ? object.medicalIssues.map((e: any) => globalThis.String(e))
        : [],
      availableEquipment: globalThis.Array.isArray(object?.availableEquipment)
        ? object.availableEquipment.map((e: any) => globalThis.String(e))
        : [],
      trainingPreferences: isSet(object.trainingPreferences) ? globalThis.String(object.trainingPreferences) : "",
      daysPerWeek: isSet(object.daysPerWeek) ? globalThis.Number(object.daysPerWeek) : 0,
      focusAreas: isSet(object.focusAreas) ? globalThis.String(object.focusAreas) : undefined,
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    if (message.fitnessLevel !== "") {
      obj.fitnessLevel = message.fitnessLevel;
    }
    if (message.fitnessGoals?.length) {
      obj.fitnessGoals = message.fitnessGoals;
    }
    if (message.medicalIssues?.length) {
      obj.medicalIssues = message.medicalIssues;
    }
    if (message.availableEquipment?.length) {
      obj.availableEquipment = message.availableEquipment;
    }
    if (message.trainingPreferences !== "") {
      obj.trainingPreferences = message.trainingPreferences;
    }
    if (message.daysPerWeek !== 0) {
      obj.daysPerWeek = Math.round(message.daysPerWeek);
    }
    if (message.focusAreas !== undefined) {
      obj.focusAreas = message.focusAreas;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.userId = object.userId ?? "";
    message.age = object.age ?? 0;
    message.height = object.height ?? 0;
    message.weight = object.weight ?? 0;
    message.fitnessLevel = object.fitnessLevel ?? "";
    message.fitnessGoals = object.fitnessGoals?.map((e) => e) || [];
    message.medicalIssues = object.medicalIssues?.map((e) => e) || [];
    message.availableEquipment = object.availableEquipment?.map((e) => e) || [];
    message.trainingPreferences = object.trainingPreferences ?? "";
    message.daysPerWeek = object.daysPerWeek ?? 0;
    message.focusAreas = object.focusAreas ?? undefined;
    return message;
  },
};

function createBaseTrainingPlan(): TrainingPlan {
  return {
    id: "",
    userId: "",
    name: "",
    objective: "",
    description: "",
    daysPerWeek: 0,
    sessions: [],
    generatedAt: "",
    modelUsed: "",
  };
}

export const TrainingPlan = {
  encode(message: TrainingPlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.objective !== "") {
      writer.uint32(34).string(message.objective);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.daysPerWeek !== 0) {
      writer.uint32(48).int32(message.daysPerWeek);
    }
    for (const v of message.sessions) {
      TrainingSession.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.generatedAt !== "") {
      writer.uint32(66).string(message.generatedAt);
    }
    if (message.modelUsed !== "") {
      writer.uint32(74).string(message.modelUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrainingPlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.objective = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.daysPerWeek = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sessions.push(TrainingSession.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.modelUsed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingPlan {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      objective: isSet(object.objective) ? globalThis.String(object.objective) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      daysPerWeek: isSet(object.daysPerWeek) ? globalThis.Number(object.daysPerWeek) : 0,
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => TrainingSession.fromJSON(e))
        : [],
      generatedAt: isSet(object.generatedAt) ? globalThis.String(object.generatedAt) : "",
      modelUsed: isSet(object.modelUsed) ? globalThis.String(object.modelUsed) : "",
    };
  },

  toJSON(message: TrainingPlan): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.objective !== "") {
      obj.objective = message.objective;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.daysPerWeek !== 0) {
      obj.daysPerWeek = Math.round(message.daysPerWeek);
    }
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => TrainingSession.toJSON(e));
    }
    if (message.generatedAt !== "") {
      obj.generatedAt = message.generatedAt;
    }
    if (message.modelUsed !== "") {
      obj.modelUsed = message.modelUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainingPlan>, I>>(base?: I): TrainingPlan {
    return TrainingPlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainingPlan>, I>>(object: I): TrainingPlan {
    const message = createBaseTrainingPlan();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.objective = object.objective ?? "";
    message.description = object.description ?? "";
    message.daysPerWeek = object.daysPerWeek ?? 0;
    message.sessions = object.sessions?.map((e) => TrainingSession.fromPartial(e)) || [];
    message.generatedAt = object.generatedAt ?? "";
    message.modelUsed = object.modelUsed ?? "";
    return message;
  },
};

function createBaseTrainingSession(): TrainingSession {
  return { dayOfWeek: 0, focus: "", exercises: [], estimatedDuration: 0, notes: undefined };
}

export const TrainingSession = {
  encode(message: TrainingSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dayOfWeek !== 0) {
      writer.uint32(8).int32(message.dayOfWeek);
    }
    if (message.focus !== "") {
      writer.uint32(18).string(message.focus);
    }
    for (const v of message.exercises) {
      ExercisePlan.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.estimatedDuration !== 0) {
      writer.uint32(32).int32(message.estimatedDuration);
    }
    if (message.notes !== undefined) {
      writer.uint32(42).string(message.notes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrainingSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.focus = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exercises.push(ExercisePlan.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.estimatedDuration = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.notes = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingSession {
    return {
      dayOfWeek: isSet(object.dayOfWeek) ? globalThis.Number(object.dayOfWeek) : 0,
      focus: isSet(object.focus) ? globalThis.String(object.focus) : "",
      exercises: globalThis.Array.isArray(object?.exercises)
        ? object.exercises.map((e: any) => ExercisePlan.fromJSON(e))
        : [],
      estimatedDuration: isSet(object.estimatedDuration) ? globalThis.Number(object.estimatedDuration) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: TrainingSession): unknown {
    const obj: any = {};
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = Math.round(message.dayOfWeek);
    }
    if (message.focus !== "") {
      obj.focus = message.focus;
    }
    if (message.exercises?.length) {
      obj.exercises = message.exercises.map((e) => ExercisePlan.toJSON(e));
    }
    if (message.estimatedDuration !== 0) {
      obj.estimatedDuration = Math.round(message.estimatedDuration);
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrainingSession>, I>>(base?: I): TrainingSession {
    return TrainingSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrainingSession>, I>>(object: I): TrainingSession {
    const message = createBaseTrainingSession();
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.focus = object.focus ?? "";
    message.exercises = object.exercises?.map((e) => ExercisePlan.fromPartial(e)) || [];
    message.estimatedDuration = object.estimatedDuration ?? 0;
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseExercisePlan(): ExercisePlan {
  return { name: "", description: "", sets: 0, reps: "", restSeconds: 0, notes: undefined, order: 0 };
}

export const ExercisePlan = {
  encode(message: ExercisePlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.sets !== 0) {
      writer.uint32(24).int32(message.sets);
    }
    if (message.reps !== "") {
      writer.uint32(34).string(message.reps);
    }
    if (message.restSeconds !== 0) {
      writer.uint32(40).int32(message.restSeconds);
    }
    if (message.notes !== undefined) {
      writer.uint32(50).string(message.notes);
    }
    if (message.order !== 0) {
      writer.uint32(56).int32(message.order);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExercisePlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExercisePlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sets = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reps = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.restSeconds = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExercisePlan {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      sets: isSet(object.sets) ? globalThis.Number(object.sets) : 0,
      reps: isSet(object.reps) ? globalThis.String(object.reps) : "",
      restSeconds: isSet(object.restSeconds) ? globalThis.Number(object.restSeconds) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: ExercisePlan): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.sets !== 0) {
      obj.sets = Math.round(message.sets);
    }
    if (message.reps !== "") {
      obj.reps = message.reps;
    }
    if (message.restSeconds !== 0) {
      obj.restSeconds = Math.round(message.restSeconds);
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExercisePlan>, I>>(base?: I): ExercisePlan {
    return ExercisePlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExercisePlan>, I>>(object: I): ExercisePlan {
    const message = createBaseExercisePlan();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.sets = object.sets ?? 0;
    message.reps = object.reps ?? "";
    message.restSeconds = object.restSeconds ?? 0;
    message.notes = object.notes ?? undefined;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseFeedbackRequest(): FeedbackRequest {
  return { userId: "", trainingId: undefined, startDate: undefined, endDate: undefined };
}

export const FeedbackRequest = {
  encode(message: FeedbackRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.trainingId !== undefined) {
      writer.uint32(18).string(message.trainingId);
    }
    if (message.startDate !== undefined) {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(34).string(message.endDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeedbackRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedbackRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : undefined,
    };
  },

  toJSON(message: FeedbackRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== undefined) {
      obj.trainingId = message.trainingId;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedbackRequest>, I>>(base?: I): FeedbackRequest {
    return FeedbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedbackRequest>, I>>(object: I): FeedbackRequest {
    const message = createBaseFeedbackRequest();
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    return message;
  },
};

function createBaseFeedbackResponse(): FeedbackResponse {
  return { userId: "", feedback: "", exerciseFeedback: [], generatedAt: "", modelUsed: "" };
}

export const FeedbackResponse = {
  encode(message: FeedbackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.feedback !== "") {
      writer.uint32(18).string(message.feedback);
    }
    for (const v of message.exerciseFeedback) {
      ExerciseFeedback.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.generatedAt !== "") {
      writer.uint32(34).string(message.generatedAt);
    }
    if (message.modelUsed !== "") {
      writer.uint32(42).string(message.modelUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeedbackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feedback = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exerciseFeedback.push(ExerciseFeedback.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.modelUsed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedbackResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : "",
      exerciseFeedback: globalThis.Array.isArray(object?.exerciseFeedback)
        ? object.exerciseFeedback.map((e: any) => ExerciseFeedback.fromJSON(e))
        : [],
      generatedAt: isSet(object.generatedAt) ? globalThis.String(object.generatedAt) : "",
      modelUsed: isSet(object.modelUsed) ? globalThis.String(object.modelUsed) : "",
    };
  },

  toJSON(message: FeedbackResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.feedback !== "") {
      obj.feedback = message.feedback;
    }
    if (message.exerciseFeedback?.length) {
      obj.exerciseFeedback = message.exerciseFeedback.map((e) => ExerciseFeedback.toJSON(e));
    }
    if (message.generatedAt !== "") {
      obj.generatedAt = message.generatedAt;
    }
    if (message.modelUsed !== "") {
      obj.modelUsed = message.modelUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedbackResponse>, I>>(base?: I): FeedbackResponse {
    return FeedbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedbackResponse>, I>>(object: I): FeedbackResponse {
    const message = createBaseFeedbackResponse();
    message.userId = object.userId ?? "";
    message.feedback = object.feedback ?? "";
    message.exerciseFeedback = object.exerciseFeedback?.map((e) => ExerciseFeedback.fromPartial(e)) || [];
    message.generatedAt = object.generatedAt ?? "";
    message.modelUsed = object.modelUsed ?? "";
    return message;
  },
};

function createBaseExerciseFeedback(): ExerciseFeedback {
  return { exerciseId: "", exerciseName: "", feedback: "", suggestion: undefined };
}

export const ExerciseFeedback = {
  encode(message: ExerciseFeedback, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exerciseId !== "") {
      writer.uint32(10).string(message.exerciseId);
    }
    if (message.exerciseName !== "") {
      writer.uint32(18).string(message.exerciseName);
    }
    if (message.feedback !== "") {
      writer.uint32(26).string(message.feedback);
    }
    if (message.suggestion !== undefined) {
      writer.uint32(34).string(message.suggestion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExerciseFeedback {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exerciseId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exerciseName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedback = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.suggestion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseFeedback {
    return {
      exerciseId: isSet(object.exerciseId) ? globalThis.String(object.exerciseId) : "",
      exerciseName: isSet(object.exerciseName) ? globalThis.String(object.exerciseName) : "",
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : undefined,
    };
  },

  toJSON(message: ExerciseFeedback): unknown {
    const obj: any = {};
    if (message.exerciseId !== "") {
      obj.exerciseId = message.exerciseId;
    }
    if (message.exerciseName !== "") {
      obj.exerciseName = message.exerciseName;
    }
    if (message.feedback !== "") {
      obj.feedback = message.feedback;
    }
    if (message.suggestion !== undefined) {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseFeedback>, I>>(base?: I): ExerciseFeedback {
    return ExerciseFeedback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseFeedback>, I>>(object: I): ExerciseFeedback {
    const message = createBaseExerciseFeedback();
    message.exerciseId = object.exerciseId ?? "";
    message.exerciseName = object.exerciseName ?? "";
    message.feedback = object.feedback ?? "";
    message.suggestion = object.suggestion ?? undefined;
    return message;
  },
};

function createBaseRecommendationRequest(): RecommendationRequest {
  return { userId: "", trainingId: undefined, focusArea: undefined };
}

export const RecommendationRequest = {
  encode(message: RecommendationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.trainingId !== undefined) {
      writer.uint32(18).string(message.trainingId);
    }
    if (message.focusArea !== undefined) {
      writer.uint32(26).string(message.focusArea);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RecommendationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.focusArea = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommendationRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : undefined,
      focusArea: isSet(object.focusArea) ? globalThis.String(object.focusArea) : undefined,
    };
  },

  toJSON(message: RecommendationRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== undefined) {
      obj.trainingId = message.trainingId;
    }
    if (message.focusArea !== undefined) {
      obj.focusArea = message.focusArea;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecommendationRequest>, I>>(base?: I): RecommendationRequest {
    return RecommendationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecommendationRequest>, I>>(object: I): RecommendationRequest {
    const message = createBaseRecommendationRequest();
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? undefined;
    message.focusArea = object.focusArea ?? undefined;
    return message;
  },
};

function createBaseRecommendationResponse(): RecommendationResponse {
  return { userId: "", recommendations: [], generatedAt: "", modelUsed: "" };
}

export const RecommendationResponse = {
  encode(message: RecommendationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.recommendations) {
      ExerciseRecommendation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.generatedAt !== "") {
      writer.uint32(26).string(message.generatedAt);
    }
    if (message.modelUsed !== "") {
      writer.uint32(34).string(message.modelUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RecommendationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recommendations.push(ExerciseRecommendation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.modelUsed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommendationResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      recommendations: globalThis.Array.isArray(object?.recommendations)
        ? object.recommendations.map((e: any) => ExerciseRecommendation.fromJSON(e))
        : [],
      generatedAt: isSet(object.generatedAt) ? globalThis.String(object.generatedAt) : "",
      modelUsed: isSet(object.modelUsed) ? globalThis.String(object.modelUsed) : "",
    };
  },

  toJSON(message: RecommendationResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.recommendations?.length) {
      obj.recommendations = message.recommendations.map((e) => ExerciseRecommendation.toJSON(e));
    }
    if (message.generatedAt !== "") {
      obj.generatedAt = message.generatedAt;
    }
    if (message.modelUsed !== "") {
      obj.modelUsed = message.modelUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecommendationResponse>, I>>(base?: I): RecommendationResponse {
    return RecommendationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecommendationResponse>, I>>(object: I): RecommendationResponse {
    const message = createBaseRecommendationResponse();
    message.userId = object.userId ?? "";
    message.recommendations = object.recommendations?.map((e) => ExerciseRecommendation.fromPartial(e)) || [];
    message.generatedAt = object.generatedAt ?? "";
    message.modelUsed = object.modelUsed ?? "";
    return message;
  },
};

function createBaseExerciseRecommendation(): ExerciseRecommendation {
  return {
    exerciseName: "",
    description: "",
    benefit: "",
    videoUrl: undefined,
    imageUrl: undefined,
    recommendedSets: 0,
    recommendedReps: "",
    recommendedRest: 0,
  };
}

export const ExerciseRecommendation = {
  encode(message: ExerciseRecommendation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exerciseName !== "") {
      writer.uint32(10).string(message.exerciseName);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.benefit !== "") {
      writer.uint32(26).string(message.benefit);
    }
    if (message.videoUrl !== undefined) {
      writer.uint32(34).string(message.videoUrl);
    }
    if (message.imageUrl !== undefined) {
      writer.uint32(42).string(message.imageUrl);
    }
    if (message.recommendedSets !== 0) {
      writer.uint32(48).int32(message.recommendedSets);
    }
    if (message.recommendedReps !== "") {
      writer.uint32(58).string(message.recommendedReps);
    }
    if (message.recommendedRest !== 0) {
      writer.uint32(64).int32(message.recommendedRest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExerciseRecommendation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExerciseRecommendation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exerciseName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.benefit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.recommendedSets = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recommendedReps = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.recommendedRest = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExerciseRecommendation {
    return {
      exerciseName: isSet(object.exerciseName) ? globalThis.String(object.exerciseName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      benefit: isSet(object.benefit) ? globalThis.String(object.benefit) : "",
      videoUrl: isSet(object.videoUrl) ? globalThis.String(object.videoUrl) : undefined,
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : undefined,
      recommendedSets: isSet(object.recommendedSets) ? globalThis.Number(object.recommendedSets) : 0,
      recommendedReps: isSet(object.recommendedReps) ? globalThis.String(object.recommendedReps) : "",
      recommendedRest: isSet(object.recommendedRest) ? globalThis.Number(object.recommendedRest) : 0,
    };
  },

  toJSON(message: ExerciseRecommendation): unknown {
    const obj: any = {};
    if (message.exerciseName !== "") {
      obj.exerciseName = message.exerciseName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.benefit !== "") {
      obj.benefit = message.benefit;
    }
    if (message.videoUrl !== undefined) {
      obj.videoUrl = message.videoUrl;
    }
    if (message.imageUrl !== undefined) {
      obj.imageUrl = message.imageUrl;
    }
    if (message.recommendedSets !== 0) {
      obj.recommendedSets = Math.round(message.recommendedSets);
    }
    if (message.recommendedReps !== "") {
      obj.recommendedReps = message.recommendedReps;
    }
    if (message.recommendedRest !== 0) {
      obj.recommendedRest = Math.round(message.recommendedRest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExerciseRecommendation>, I>>(base?: I): ExerciseRecommendation {
    return ExerciseRecommendation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExerciseRecommendation>, I>>(object: I): ExerciseRecommendation {
    const message = createBaseExerciseRecommendation();
    message.exerciseName = object.exerciseName ?? "";
    message.description = object.description ?? "";
    message.benefit = object.benefit ?? "";
    message.videoUrl = object.videoUrl ?? undefined;
    message.imageUrl = object.imageUrl ?? undefined;
    message.recommendedSets = object.recommendedSets ?? 0;
    message.recommendedReps = object.recommendedReps ?? "";
    message.recommendedRest = object.recommendedRest ?? 0;
    return message;
  },
};

function createBaseProgressAnalysisRequest(): ProgressAnalysisRequest {
  return { userId: "", trainingId: undefined, startDate: undefined, endDate: undefined };
}

export const ProgressAnalysisRequest = {
  encode(message: ProgressAnalysisRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.trainingId !== undefined) {
      writer.uint32(18).string(message.trainingId);
    }
    if (message.startDate !== undefined) {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(34).string(message.endDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProgressAnalysisRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressAnalysisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressAnalysisRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      trainingId: isSet(object.trainingId) ? globalThis.String(object.trainingId) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : undefined,
    };
  },

  toJSON(message: ProgressAnalysisRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.trainingId !== undefined) {
      obj.trainingId = message.trainingId;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressAnalysisRequest>, I>>(base?: I): ProgressAnalysisRequest {
    return ProgressAnalysisRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressAnalysisRequest>, I>>(object: I): ProgressAnalysisRequest {
    const message = createBaseProgressAnalysisRequest();
    message.userId = object.userId ?? "";
    message.trainingId = object.trainingId ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    return message;
  },
};

function createBaseProgressAnalysisResponse(): ProgressAnalysisResponse {
  return {
    userId: "",
    overallAnalysis: "",
    strengthAreas: [],
    weaknessAreas: [],
    actionItems: [],
    generatedAt: "",
    modelUsed: "",
  };
}

export const ProgressAnalysisResponse = {
  encode(message: ProgressAnalysisResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.overallAnalysis !== "") {
      writer.uint32(18).string(message.overallAnalysis);
    }
    for (const v of message.strengthAreas) {
      StrengthAreaAnalysis.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.weaknessAreas) {
      WeaknessAreaAnalysis.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.actionItems) {
      ActionItem.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.generatedAt !== "") {
      writer.uint32(50).string(message.generatedAt);
    }
    if (message.modelUsed !== "") {
      writer.uint32(58).string(message.modelUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProgressAnalysisResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressAnalysisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overallAnalysis = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strengthAreas.push(StrengthAreaAnalysis.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.weaknessAreas.push(WeaknessAreaAnalysis.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actionItems.push(ActionItem.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.modelUsed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressAnalysisResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      overallAnalysis: isSet(object.overallAnalysis) ? globalThis.String(object.overallAnalysis) : "",
      strengthAreas: globalThis.Array.isArray(object?.strengthAreas)
        ? object.strengthAreas.map((e: any) => StrengthAreaAnalysis.fromJSON(e))
        : [],
      weaknessAreas: globalThis.Array.isArray(object?.weaknessAreas)
        ? object.weaknessAreas.map((e: any) => WeaknessAreaAnalysis.fromJSON(e))
        : [],
      actionItems: globalThis.Array.isArray(object?.actionItems)
        ? object.actionItems.map((e: any) => ActionItem.fromJSON(e))
        : [],
      generatedAt: isSet(object.generatedAt) ? globalThis.String(object.generatedAt) : "",
      modelUsed: isSet(object.modelUsed) ? globalThis.String(object.modelUsed) : "",
    };
  },

  toJSON(message: ProgressAnalysisResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.overallAnalysis !== "") {
      obj.overallAnalysis = message.overallAnalysis;
    }
    if (message.strengthAreas?.length) {
      obj.strengthAreas = message.strengthAreas.map((e) => StrengthAreaAnalysis.toJSON(e));
    }
    if (message.weaknessAreas?.length) {
      obj.weaknessAreas = message.weaknessAreas.map((e) => WeaknessAreaAnalysis.toJSON(e));
    }
    if (message.actionItems?.length) {
      obj.actionItems = message.actionItems.map((e) => ActionItem.toJSON(e));
    }
    if (message.generatedAt !== "") {
      obj.generatedAt = message.generatedAt;
    }
    if (message.modelUsed !== "") {
      obj.modelUsed = message.modelUsed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressAnalysisResponse>, I>>(base?: I): ProgressAnalysisResponse {
    return ProgressAnalysisResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressAnalysisResponse>, I>>(object: I): ProgressAnalysisResponse {
    const message = createBaseProgressAnalysisResponse();
    message.userId = object.userId ?? "";
    message.overallAnalysis = object.overallAnalysis ?? "";
    message.strengthAreas = object.strengthAreas?.map((e) => StrengthAreaAnalysis.fromPartial(e)) || [];
    message.weaknessAreas = object.weaknessAreas?.map((e) => WeaknessAreaAnalysis.fromPartial(e)) || [];
    message.actionItems = object.actionItems?.map((e) => ActionItem.fromPartial(e)) || [];
    message.generatedAt = object.generatedAt ?? "";
    message.modelUsed = object.modelUsed ?? "";
    return message;
  },
};

function createBaseStrengthAreaAnalysis(): StrengthAreaAnalysis {
  return { area: "", description: "", improvementPercentage: 0 };
}

export const StrengthAreaAnalysis = {
  encode(message: StrengthAreaAnalysis, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.area !== "") {
      writer.uint32(10).string(message.area);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.improvementPercentage !== 0) {
      writer.uint32(29).float(message.improvementPercentage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrengthAreaAnalysis {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrengthAreaAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.area = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.improvementPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrengthAreaAnalysis {
    return {
      area: isSet(object.area) ? globalThis.String(object.area) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      improvementPercentage: isSet(object.improvementPercentage) ? globalThis.Number(object.improvementPercentage) : 0,
    };
  },

  toJSON(message: StrengthAreaAnalysis): unknown {
    const obj: any = {};
    if (message.area !== "") {
      obj.area = message.area;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.improvementPercentage !== 0) {
      obj.improvementPercentage = message.improvementPercentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrengthAreaAnalysis>, I>>(base?: I): StrengthAreaAnalysis {
    return StrengthAreaAnalysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrengthAreaAnalysis>, I>>(object: I): StrengthAreaAnalysis {
    const message = createBaseStrengthAreaAnalysis();
    message.area = object.area ?? "";
    message.description = object.description ?? "";
    message.improvementPercentage = object.improvementPercentage ?? 0;
    return message;
  },
};

function createBaseWeaknessAreaAnalysis(): WeaknessAreaAnalysis {
  return { area: "", description: "", suggestion: undefined };
}

export const WeaknessAreaAnalysis = {
  encode(message: WeaknessAreaAnalysis, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.area !== "") {
      writer.uint32(10).string(message.area);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.suggestion !== undefined) {
      writer.uint32(26).string(message.suggestion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WeaknessAreaAnalysis {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeaknessAreaAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.area = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.suggestion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeaknessAreaAnalysis {
    return {
      area: isSet(object.area) ? globalThis.String(object.area) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : undefined,
    };
  },

  toJSON(message: WeaknessAreaAnalysis): unknown {
    const obj: any = {};
    if (message.area !== "") {
      obj.area = message.area;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.suggestion !== undefined) {
      obj.suggestion = message.suggestion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeaknessAreaAnalysis>, I>>(base?: I): WeaknessAreaAnalysis {
    return WeaknessAreaAnalysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeaknessAreaAnalysis>, I>>(object: I): WeaknessAreaAnalysis {
    const message = createBaseWeaknessAreaAnalysis();
    message.area = object.area ?? "";
    message.description = object.description ?? "";
    message.suggestion = object.suggestion ?? undefined;
    return message;
  },
};

function createBaseActionItem(): ActionItem {
  return { description: "", reason: "", priority: 0 };
}

export const ActionItem = {
  encode(message: ActionItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActionItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionItem {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: ActionItem): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionItem>, I>>(base?: I): ActionItem {
    return ActionItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionItem>, I>>(object: I): ActionItem {
    const message = createBaseActionItem();
    message.description = object.description ?? "";
    message.reason = object.reason ?? "";
    message.priority = object.priority ?? 0;
    return message;
  },
};

export interface AIService {
  /** Generate training feedback based on user progress */
  GenerateFeedback(request: FeedbackRequest): Promise<FeedbackResponse>;
  /** Generate workout recommendations */
  GenerateRecommendations(request: RecommendationRequest): Promise<RecommendationResponse>;
  /** Analyze user progress */
  AnalyzeProgress(request: ProgressAnalysisRequest): Promise<ProgressAnalysisResponse>;
  /** Generate training plan based on user profile */
  GenerateTrainingPlan(request: UserProfile): Promise<TrainingPlan>;
}

export const AIServiceServiceName = "ai.AIService";
export class AIServiceClientImpl implements AIService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AIServiceServiceName;
    this.rpc = rpc;
    this.GenerateFeedback = this.GenerateFeedback.bind(this);
    this.GenerateRecommendations = this.GenerateRecommendations.bind(this);
    this.AnalyzeProgress = this.AnalyzeProgress.bind(this);
    this.GenerateTrainingPlan = this.GenerateTrainingPlan.bind(this);
  }
  GenerateFeedback(request: FeedbackRequest): Promise<FeedbackResponse> {
    const data = FeedbackRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateFeedback", data);
    return promise.then((data) => FeedbackResponse.decode(_m0.Reader.create(data)));
  }

  GenerateRecommendations(request: RecommendationRequest): Promise<RecommendationResponse> {
    const data = RecommendationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateRecommendations", data);
    return promise.then((data) => RecommendationResponse.decode(_m0.Reader.create(data)));
  }

  AnalyzeProgress(request: ProgressAnalysisRequest): Promise<ProgressAnalysisResponse> {
    const data = ProgressAnalysisRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AnalyzeProgress", data);
    return promise.then((data) => ProgressAnalysisResponse.decode(_m0.Reader.create(data)));
  }

  GenerateTrainingPlan(request: UserProfile): Promise<TrainingPlan> {
    const data = UserProfile.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateTrainingPlan", data);
    return promise.then((data) => TrainingPlan.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
